"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

try:
    import cStringIO.StringIO as BytesIO
except ImportError:
    from io import BytesIO
import struct

class haptic_array_t(object):
    __slots__ = ["utime", "state_id", "has_input", "see_ground", "ground_height", "ground_height_std", "trans_xyzrpy", "num_ranges", "ranges_state", "ranges_m", "ranges_ir_valid", "ranges_m_ir", "ranges_m_dense", "ranges_m_hit", "num_traj", "ranges_trajlib_hit", "obj_ids", "tts_data", "bbox_rgb_xs", "bbox_rgb_ys", "bbox_rgb_ws", "bbox_rgb_hs", "bbox_d_xs", "bbox_d_ys", "bbox_d_ws", "bbox_d_hs", "ranges", "h_min_r", "h_max_r", "h_pattern_setting", "intensities", "frequencies", "states"]

    def __init__(self):
        self.utime = 0
        self.state_id = 0
        self.has_input = 0
        self.see_ground = 0
        self.ground_height = 0.0
        self.ground_height_std = 0.0
        self.trans_xyzrpy = [ 0.0 for dim0 in range(6) ]
        self.num_ranges = 0
        self.ranges_state = []
        self.ranges_m = []
        self.ranges_ir_valid = []
        self.ranges_m_ir = []
        self.ranges_m_dense = []
        self.ranges_m_hit = []
        self.num_traj = 0
        self.ranges_trajlib_hit = []
        self.obj_ids = []
        self.tts_data = ""
        self.bbox_rgb_xs = []
        self.bbox_rgb_ys = []
        self.bbox_rgb_ws = []
        self.bbox_rgb_hs = []
        self.bbox_d_xs = []
        self.bbox_d_ys = []
        self.bbox_d_ws = []
        self.bbox_d_hs = []
        self.ranges = []
        self.h_min_r = 0.0
        self.h_max_r = 0.0
        self.h_pattern_setting = 0
        self.intensities = []
        self.frequencies = []
        self.states = []

    def encode(self):
        buf = BytesIO()
        buf.write(haptic_array_t._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">qihhdd", self.utime, self.state_id, self.has_input, self.see_ground, self.ground_height, self.ground_height_std))
        buf.write(struct.pack('>6d', *self.trans_xyzrpy[:6]))
        buf.write(struct.pack(">i", self.num_ranges))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.ranges_state[:self.num_ranges]))
        buf.write(struct.pack('>%dd' % self.num_ranges, *self.ranges_m[:self.num_ranges]))
        buf.write(struct.pack('>%dd' % self.num_ranges, *self.ranges_ir_valid[:self.num_ranges]))
        buf.write(struct.pack('>%dd' % self.num_ranges, *self.ranges_m_ir[:self.num_ranges]))
        buf.write(struct.pack('>%dd' % self.num_ranges, *self.ranges_m_dense[:self.num_ranges]))
        buf.write(struct.pack('>%dd' % self.num_ranges, *self.ranges_m_hit[:self.num_ranges]))
        buf.write(struct.pack(">h", self.num_traj))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.ranges_trajlib_hit[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.obj_ids[:self.num_ranges]))
        __tts_data_encoded = self.tts_data.encode('utf-8')
        buf.write(struct.pack('>I', len(__tts_data_encoded)+1))
        buf.write(__tts_data_encoded)
        buf.write(b"\0")
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.bbox_rgb_xs[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.bbox_rgb_ys[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.bbox_rgb_ws[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.bbox_rgb_hs[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.bbox_d_xs[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.bbox_d_ys[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.bbox_d_ws[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.bbox_d_hs[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.ranges[:self.num_ranges]))
        buf.write(struct.pack(">ddh", self.h_min_r, self.h_max_r, self.h_pattern_setting))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.intensities[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.frequencies[:self.num_ranges]))
        buf.write(struct.pack('>%dh' % self.num_ranges, *self.states[:self.num_ranges]))

    def decode(data):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != haptic_array_t._get_packed_fingerprint():
            raise ValueError("Decode error")
        return haptic_array_t._decode_one(buf)
    decode = staticmethod(decode)

    def _decode_one(buf):
        self = haptic_array_t()
        self.utime, self.state_id, self.has_input, self.see_ground, self.ground_height, self.ground_height_std = struct.unpack(">qihhdd", buf.read(32))
        self.trans_xyzrpy = struct.unpack('>6d', buf.read(48))
        self.num_ranges = struct.unpack(">i", buf.read(4))[0]
        self.ranges_state = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.ranges_m = struct.unpack('>%dd' % self.num_ranges, buf.read(self.num_ranges * 8))
        self.ranges_ir_valid = struct.unpack('>%dd' % self.num_ranges, buf.read(self.num_ranges * 8))
        self.ranges_m_ir = struct.unpack('>%dd' % self.num_ranges, buf.read(self.num_ranges * 8))
        self.ranges_m_dense = struct.unpack('>%dd' % self.num_ranges, buf.read(self.num_ranges * 8))
        self.ranges_m_hit = struct.unpack('>%dd' % self.num_ranges, buf.read(self.num_ranges * 8))
        self.num_traj = struct.unpack(">h", buf.read(2))[0]
        self.ranges_trajlib_hit = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.obj_ids = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        __tts_data_len = struct.unpack('>I', buf.read(4))[0]
        self.tts_data = buf.read(__tts_data_len)[:-1].decode('utf-8', 'replace')
        self.bbox_rgb_xs = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.bbox_rgb_ys = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.bbox_rgb_ws = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.bbox_rgb_hs = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.bbox_d_xs = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.bbox_d_ys = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.bbox_d_ws = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.bbox_d_hs = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.ranges = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.h_min_r, self.h_max_r, self.h_pattern_setting = struct.unpack(">ddh", buf.read(18))
        self.intensities = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.frequencies = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        self.states = struct.unpack('>%dh' % self.num_ranges, buf.read(self.num_ranges * 2))
        return self
    _decode_one = staticmethod(_decode_one)

    _hash = None
    def _get_hash_recursive(parents):
        if haptic_array_t in parents: return 0
        tmphash = (0x7b14f4016d8e928e) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff)  + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _get_hash_recursive = staticmethod(_get_hash_recursive)
    _packed_fingerprint = None

    def _get_packed_fingerprint():
        if haptic_array_t._packed_fingerprint is None:
            haptic_array_t._packed_fingerprint = struct.pack(">Q", haptic_array_t._get_hash_recursive([]))
        return haptic_array_t._packed_fingerprint
    _get_packed_fingerprint = staticmethod(_get_packed_fingerprint)

